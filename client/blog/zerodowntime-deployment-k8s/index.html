<!DOCTYPE html><html lang="en"> <head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Hal-hal yang perlu diperhatikan untuk menerapkan Zero Downtime pada k8s · AWNESIA</title><script>
      if (
        localStorage.getItem("color-theme") === "dark" ||
        (!("color-theme" in localStorage) &&
          window.matchMedia("(prefers-color-scheme: dark)").matches)
      ) {
        document.documentElement.classList.add("dark");
      } else {
        document.documentElement.classList.remove("dark");
      }
    </script><link rel="stylesheet" href="/_astro/about.CEpY85dL.css"><script>window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); };
		var script = document.createElement('script');
		script.defer = true;
		script.src = '/_vercel/insights/script.js';
		var head = document.querySelector('head');
		head.appendChild(script);
	</script></head> <body class="bg-gray-50 text-slate-900 dark:bg-slate-950 dark:text-slate-50 antialiased selection:bg-blue-100 transition-colors duration-300"> <main class="min-h-screen px-4 py-8 md:px-6"> <div class="max-w-5xl mx-auto"> <header class="flex items-center justify-between gap-6 mb-10 border-b border-slate-200 dark:border-slate-800 pb-6"> <div class="flex items-center gap-6"> <a href="/" class="font-bold text-xl tracking-tight hover:text-blue-600 dark:hover:text-blue-400 transition-colors"> AWNESIA </a> <nav class="hidden md:flex items-center gap-6 text-sm font-medium text-slate-600 dark:text-slate-400"> <a class="hover:text-blue-600 dark:hover:text-blue-400 transition-colors" href="/">Home</a> <a class="hover:text-blue-600 dark:hover:text-blue-400 transition-colors" href="/blog">Blog</a> <a class="hover:text-blue-600 dark:hover:text-blue-400 transition-colors" href="/about">About</a> </nav> </div> <div class="flex items-center gap-4"> <nav class="md:hidden flex items-center gap-4 text-xs font-medium text-slate-600 dark:text-slate-400"> <a href="/">Home</a> <a href="/blog">Blog</a> </nav> <button id="theme-toggle" type="button" class="inline-flex items-center p-2 text-sm font-medium text-slate-600 dark:text-slate-400 bg-white dark:bg-slate-900 border border-slate-200 dark:border-slate-800 rounded-lg hover:bg-slate-50 dark:hover:bg-slate-800 focus:outline-none transition-colors" aria-label="Toggle theme"> <svg id="theme-toggle-dark-icon" class="hidden w-5 h-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"> <path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path> </svg> <svg id="theme-toggle-light-icon" class="hidden w-5 h-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"> <path d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" fill-rule="evenodd" clip-rule="evenodd"></path> </svg> </button> <script>
  const initTheme = () => {
    const themeToggleDarkIcon = document.getElementById(
      "theme-toggle-dark-icon",
    );
    const themeToggleLightIcon = document.getElementById(
      "theme-toggle-light-icon",
    );
    const themeToggleBtn = document.getElementById("theme-toggle");

    if (!themeToggleBtn) return;

    // Set icons based on current theme
    if (
      localStorage.getItem("color-theme") === "dark" ||
      (!("color-theme" in localStorage) &&
        window.matchMedia("(prefers-color-scheme: dark)").matches)
    ) {
      themeToggleLightIcon?.classList.remove("hidden");
      themeToggleDarkIcon?.classList.add("hidden");
      document.documentElement.classList.add("dark");
    } else {
      themeToggleDarkIcon?.classList.remove("hidden");
      themeToggleLightIcon?.classList.add("hidden");
      document.documentElement.classList.remove("dark");
    }

    // Remove existing listener to avoid multiples
    themeToggleBtn.replaceWith(themeToggleBtn.cloneNode(true));
    const newBtn = document.getElementById("theme-toggle");

    newBtn?.addEventListener("click", function () {
      // toggle icons inside button
      const darkIcon = document.getElementById("theme-toggle-dark-icon");
      const lightIcon = document.getElementById("theme-toggle-light-icon");
      darkIcon?.classList.toggle("hidden");
      lightIcon?.classList.toggle("hidden");

      if (document.documentElement.classList.contains("dark")) {
        document.documentElement.classList.remove("dark");
        localStorage.setItem("color-theme", "light");
      } else {
        document.documentElement.classList.add("dark");
        localStorage.setItem("color-theme", "dark");
      }
    });
  };

  // Run on initial load
  initTheme();

  // Run after every page swap (for View Transitions)
  document.addEventListener("astro:after-swap", initTheme);
</script> </div> </header>  <article class="max-w-3xl mx-auto"> <a href="/blog" class="inline-flex items-center text-sm font-semibold text-blue-600 dark:text-blue-400 mb-8 hover:text-blue-700 dark:hover:text-blue-300 transition"> <span class="mr-1">←</span> Back to blog
</a>  <header class="mb-12"> <h1 class="text-4xl md:text-5xl font-bold tracking-tight text-slate-900 dark:text-white mb-4 leading-tight"> Hal-hal yang perlu diperhatikan untuk menerapkan Zero Downtime pada k8s </h1> <div class="flex items-center gap-3"> <p class="text-sm font-bold text-blue-600 dark:text-blue-400 uppercase tracking-wider"> September 20, 2022 </p> <span class="text-slate-300 dark:text-slate-700">•</span> <p class="text-sm text-slate-500 dark:text-slate-400 italic">
By Yudi Yuswita Sunarto </p> </div> </header> <div class="prose prose-slate lg:prose-xl max-w-none dark:prose-invert prose-headings:text-slate-900 dark:prose-headings:text-white prose-a:text-blue-600 dark:prose-a:text-blue-400 hover:prose-a:text-blue-700 dark:hover:prose-a:text-blue-300"> <article><p><img src="https://img.freepik.com/free-photo/vintage-clock_74190-1472.jpg?w=1380&t=st=1667445622~exp=1667446222~hmac=f3b9a7a6ccf03d5d05613b3f08a9c42028833518cb6a756e0c753854fa7cb84f" alt="Zero Downtime"/> Okee, untuk kali ini catatan yang akan ditulis adalah mengenai hal-hal apa yang perlu diperhatikan ketika menerapkan Zero Downtime pada kubernetes.</p><h2 id="pertama--replicasets">Pertama | ReplicaSets</h2><p>Menentukan ReplicaSets pada jumlah batas minimum, yaitu 3. Kenapa demikian? Ini dikarenakan jika suatu saat ada pods kita yang crash kita masih memiliki pods yang lain yang masih berjalan.</p><p>Links terkait <a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/">ReplicaSets</a></p><h2 id="kedua--podantiaffinity">Kedua | podAntiAffinity</h2><p>Bayangkan apabila anda memiliki 3 replicasets, akan tetapi semuanya berada pada 1 node dan node itu tidak bisa diakses. Maka semua service tidak bisa diakses juga, maka butuh yang namanya &quot;podAntiAffinity&quot; yang berguna untuk melakukan pemasangan pod sesuai dengan rule yang sudah kita tentukan.</p><p>Pada kasus ini jika kita memiliki 3 replicasets, maka hal yang terbaik yang bisa kita lakukan adalah memisah replica tersebut ke setiap node yang kita miliki, sehingga tidak menumpuk di 1 node saja. Apa bila sewaktu-waktu ada node yang tidak bisa diakses, masih ada replicasets kita yang berjalan pada node lain.</p><p>Links terkait <a href="https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity">podAntiAffinity</a></p><p>contoh yaml</p><pre>apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis-cache
spec:
  selector:
    matchLabels:
      app: store
  replicas: 3
  template:
    metadata:
      labels:
        app: store
    spec:
      affinity:
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchExpressions:
              - key: app
                operator: In
                values:
                - store
            topologyKey: &quot;kubernetes.io/hostname&quot;
      containers:
      - name: redis-server
        image: redis:3.2-alpine
</pre><h2 id="ketiga--resource-declaration">Ketiga | Resource Declaration</h2><p>Ini perlu untuk ditentukan untuk menanggulangi ketika node mengalami overused, dikarenakan dari deployment yang sudah terpasang menggunakan default resource, padahal untuk penggunaan tidak terlalu tinggi.</p><p>Maka perlu adanya deklarasi untuk minimum dan maksimum resources, agar setiap pod yang jalan menggunakan resource sesuai kebutuhan saja.</p><p>Link terkait <a href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/">Resource Declaration</a></p><h2 id="keempat--readiness--liveness-probe">Keempat | Readiness &amp; Liveness Probe</h2><p>Dalam menjalankan pod kita butuh untuk mengetahui pod tersebut sudah bisa diakses atau belum, lebih dari itu meskipun pod sudah bisa diakses namun pada kondisi tertentu pod gagal untuk memproses service padahal secara status masih running. Oleh karena itu kita membutuhkan yang namanya Readiness &amp; Liveness, yang berfungsi:</p><ul><li>mengetahui pod sudah siap untuk diakses atau belum</li><li>mengetahui jika pod tidak bisa diakses pada waktu tertentu ketika pod sudah berjalan</li></ul><p>dari kegunaan tersebut pod yang tidak bisa diakses akan otomatis recreate(dibuat ulang) sesuai dengan parameter yang kita tentukan.</p><p>Link terkait <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/">Readiness &amp; Liveness</a></p><h2 id="kelima--rolling-update-optionalimprovement">Kelima | Rolling Update (Optional&amp;improvement)</h2><p>Pada dasarnya untuk metode deployment rolling update sudah ada secara default. Namun sebelum itu kita perlu paham terlebih dahulu apa itu maxSurge dan maxUnavailable. maxSurge berfungsi untuk mengatur berapa banyak pod yang akan kita tambahkan ketika terjadi update. maxUnavailable berfungsi untuk mengatur berapa banyak pod yang akan dihilangkan ketika proses rolling update.</p><p>Masing-masing antara maxSurge dan maxUnavailable bisa diatur menggunakan persentase maupun jumlah pod.</p><p>Link terkait <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#rolling-update-deployment">Rolling Update (maxSurge &amp; max unavailable)</a></p></article> </div> </article>  </div> </main> </body></html>
<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>Hal-hal yang perlu diperhatikan untuk menerapkan Zero Downtime pada k8s | AWNESIA</title>
<meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="
Okee, untuk kali ini catatan yang akan ditulis adalah mengenai hal-hal apa yang perlu diperhatikan ketika menerapkan Zero Downtime pada kubernetes.
Pertama | ReplicaSets
Menentukan ReplicaSets pada jumlah batas minimum, yaitu 3. Kenapa demikian? Ini dikarenakan jika suatu saat ada pods kita yang crash kita masih memiliki pods yang lain yang masih berjalan.
Links terkait ReplicaSets
Kedua | podAntiAffinity
Bayangkan apabila anda memiliki 3 replicasets, akan tetapi semuanya berada pada 1 node dan node itu tidak bisa diakses. Maka semua service tidak bisa diakses juga, maka butuh yang namanya &ldquo;podAntiAffinity&rdquo; yang berguna untuk melakukan pemasangan pod sesuai dengan rule yang sudah kita tentukan."><meta name=generator content="Hugo 0.141.0"><meta name=robots content="index, follow"><meta name=author content="Yudi Tata"><link rel=stylesheet href=/ananke/css/main.min.d05fb5f317fcf33b3a52936399bdf6f47dc776516e1692e412ec7d76f4a5faa2.css><link rel=canonical href=https://yuswitayudi.github.io/posts/zerodowntime-deployment-k8s/><meta property="og:url" content="https://yuswitayudi.github.io/posts/zerodowntime-deployment-k8s/"><meta property="og:site_name" content="AWNESIA"><meta property="og:title" content="Hal-hal yang perlu diperhatikan untuk menerapkan Zero Downtime pada k8s"><meta property="og:description" content="Okee, untuk kali ini catatan yang akan ditulis adalah mengenai hal-hal apa yang perlu diperhatikan ketika menerapkan Zero Downtime pada kubernetes.
Pertama | ReplicaSets Menentukan ReplicaSets pada jumlah batas minimum, yaitu 3. Kenapa demikian? Ini dikarenakan jika suatu saat ada pods kita yang crash kita masih memiliki pods yang lain yang masih berjalan.
Links terkait ReplicaSets
Kedua | podAntiAffinity Bayangkan apabila anda memiliki 3 replicasets, akan tetapi semuanya berada pada 1 node dan node itu tidak bisa diakses. Maka semua service tidak bisa diakses juga, maka butuh yang namanya “podAntiAffinity” yang berguna untuk melakukan pemasangan pod sesuai dengan rule yang sudah kita tentukan."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-20T10:05:59+07:00"><meta property="article:modified_time" content="2022-09-20T10:05:59+07:00"><meta property="article:tag" content="Kubernetes"><meta property="og:image" content="https://yuswitayudi.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta itemprop=name content="Hal-hal yang perlu diperhatikan untuk menerapkan Zero Downtime pada k8s"><meta itemprop=description content="Okee, untuk kali ini catatan yang akan ditulis adalah mengenai hal-hal apa yang perlu diperhatikan ketika menerapkan Zero Downtime pada kubernetes.
Pertama | ReplicaSets Menentukan ReplicaSets pada jumlah batas minimum, yaitu 3. Kenapa demikian? Ini dikarenakan jika suatu saat ada pods kita yang crash kita masih memiliki pods yang lain yang masih berjalan.
Links terkait ReplicaSets
Kedua | podAntiAffinity Bayangkan apabila anda memiliki 3 replicasets, akan tetapi semuanya berada pada 1 node dan node itu tidak bisa diakses. Maka semua service tidak bisa diakses juga, maka butuh yang namanya “podAntiAffinity” yang berguna untuk melakukan pemasangan pod sesuai dengan rule yang sudah kita tentukan."><meta itemprop=datePublished content="2022-09-20T10:05:59+07:00"><meta itemprop=dateModified content="2022-09-20T10:05:59+07:00"><meta itemprop=wordCount content="428"><meta itemprop=image content="https://yuswitayudi.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta itemprop=keywords content="Kubernetes"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://yuswitayudi.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Hal-hal yang perlu diperhatikan untuk menerapkan Zero Downtime pada k8s"><meta name=twitter:description content="Okee, untuk kali ini catatan yang akan ditulis adalah mengenai hal-hal apa yang perlu diperhatikan ketika menerapkan Zero Downtime pada kubernetes.
Pertama | ReplicaSets Menentukan ReplicaSets pada jumlah batas minimum, yaitu 3. Kenapa demikian? Ini dikarenakan jika suatu saat ada pods kita yang crash kita masih memiliki pods yang lain yang masih berjalan.
Links terkait ReplicaSets
Kedua | podAntiAffinity Bayangkan apabila anda memiliki 3 replicasets, akan tetapi semuanya berada pada 1 node dan node itu tidak bisa diakses. Maka semua service tidak bisa diakses juga, maka butuh yang namanya “podAntiAffinity” yang berguna untuk melakukan pemasangan pod sesuai dengan rule yang sudah kita tentukan."></head><body class="ma0 avenir bg-near-white production"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">AWNESIA</a><div class="flex-l items-center"><ul class="pl0 mr3"><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/about/ title="about page">about</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/posts/ title="posts page">posts</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/tags/ title="tags page">tags</a></li></ul><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked ttu">Posts</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">Hal-hal yang perlu diperhatikan untuk menerapkan Zero Downtime pada k8s</h1><p class=tracked>By <strong>Yudi Tata</strong></p><time class="f6 mv4 dib tracked" datetime=2022-09-20T10:05:59+07:00>September 20, 2022</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p><img src="https://img.freepik.com/free-photo/vintage-clock_74190-1472.jpg?w=1380&amp;t=st=1667445622~exp=1667446222~hmac=f3b9a7a6ccf03d5d05613b3f08a9c42028833518cb6a756e0c753854fa7cb84f" alt="Zero Downtime">
Okee, untuk kali ini catatan yang akan ditulis adalah mengenai hal-hal apa yang perlu diperhatikan ketika menerapkan Zero Downtime pada kubernetes.</p><h2 id=pertama--replicasets>Pertama | ReplicaSets</h2><p>Menentukan ReplicaSets pada jumlah batas minimum, yaitu 3. Kenapa demikian? Ini dikarenakan jika suatu saat ada pods kita yang crash kita masih memiliki pods yang lain yang masih berjalan.</p><p>Links terkait <a href=https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/>ReplicaSets</a></p><h2 id=kedua--podantiaffinity>Kedua | podAntiAffinity</h2><p>Bayangkan apabila anda memiliki 3 replicasets, akan tetapi semuanya berada pada 1 node dan node itu tidak bisa diakses. Maka semua service tidak bisa diakses juga, maka butuh yang namanya &ldquo;podAntiAffinity&rdquo; yang berguna untuk melakukan pemasangan pod sesuai dengan rule yang sudah kita tentukan.</p><p>Pada kasus ini jika kita memiliki 3 replicasets, maka hal yang terbaik yang bisa kita lakukan adalah memisah replica tersebut ke setiap node yang kita miliki, sehingga tidak menumpuk di 1 node saja. Apa bila sewaktu-waktu ada node yang tidak bisa diakses, masih ada replicasets kita yang berjalan pada node lain.</p><p>Links terkait <a href=https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity>podAntiAffinity</a></p><p>contoh yaml</p><pre tabindex=0><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis-cache
spec:
  selector:
    matchLabels:
      app: store
  replicas: 3
  template:
    metadata:
      labels:
        app: store
    spec:
      affinity:
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchExpressions:
              - key: app
                operator: In
                values:
                - store
            topologyKey: &#34;kubernetes.io/hostname&#34;
      containers:
      - name: redis-server
        image: redis:3.2-alpine
</code></pre><h2 id=ketiga--resource-declaration>Ketiga | Resource Declaration</h2><p>Ini perlu untuk ditentukan untuk menanggulangi ketika node mengalami overused, dikarenakan dari deployment yang sudah terpasang menggunakan default resource, padahal untuk penggunaan tidak terlalu tinggi.</p><p>Maka perlu adanya deklarasi untuk minimum dan maksimum resources, agar setiap pod yang jalan menggunakan resource sesuai kebutuhan saja.</p><p>Link terkait <a href=https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>Resource Declaration</a></p><h2 id=keempat--readiness--liveness-probe>Keempat | Readiness & Liveness Probe</h2><p>Dalam menjalankan pod kita butuh untuk mengetahui pod tersebut sudah bisa diakses atau belum, lebih dari itu meskipun pod sudah bisa diakses namun pada kondisi tertentu pod gagal untuk memproses service padahal secara status masih running.
Oleh karena itu kita membutuhkan yang namanya Readiness & Liveness, yang berfungsi:</p><ul><li>mengetahui pod sudah siap untuk diakses atau belum</li><li>mengetahui jika pod tidak bisa diakses pada waktu tertentu ketika pod sudah berjalan</li></ul><p>dari kegunaan tersebut pod yang tidak bisa diakses akan otomatis recreate(dibuat ulang) sesuai dengan parameter yang kita tentukan.</p><p>Link terkait <a href=https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/>Readiness & Liveness</a></p><h2 id=kelima--rolling-update-optionalimprovement>Kelima | Rolling Update (Optional&amp;improvement)</h2><p>Pada dasarnya untuk metode deployment rolling update sudah ada secara default. Namun sebelum itu kita perlu paham terlebih dahulu apa itu maxSurge dan maxUnavailable. maxSurge berfungsi untuk mengatur berapa banyak pod yang akan kita tambahkan ketika terjadi update. maxUnavailable berfungsi untuk mengatur berapa banyak pod yang akan dihilangkan ketika proses rolling update.</p><p>Masing-masing antara maxSurge dan maxUnavailable bisa diatur menggunakan persentase maupun jumlah pod.</p><p>Link terkait <a href=https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#rolling-update-deployment>Rolling Update (maxSurge & max unavailable)</a></p><ul class=pa0><li class="list di"><a href=/tags/kubernetes/ class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Kubernetes</a></li></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"><div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links"><p class="f5 b mb3">Related</p><ul class="pa0 list"><li class=mb2><a href=/posts/cara-posting/>Cara posting menggunakan hugo</a></li><li class=mb2><a href=/posts/intro/>Intro</a></li></ul></div></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://yuswitayudi.github.io/>&copy; AWNESIA 2025</a><div><div class=ananke-socials></div></div></div></footer></body></html>